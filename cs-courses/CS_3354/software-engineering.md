CS 3354 Software Engineering (3 semester credit hours) Introduction to software life cycle models. Software requirements engineering, formal specification and validation. Techniques for software design and testing. Cost estimation models. Issues in software quality assurance and software maintenance.
Absolutely — CS 3354: Software Engineering is where you shift from “just writing code” to learning how to build real software systems that teams can maintain, grow, and ship reliably.

⸻

1. Software Development Life Cycle (SDLC) Models

These are the big-picture ways a project flows from idea → to product:
• Waterfall – each phase done before the next
• Agile/Scrum – iterative, team-focused development
• Spiral / V-model / Incremental

You learned when to use each, and why Agile is popular in the real world.

⸻

2. Requirements Engineering

“How do we figure out what the software should actually do?”

    •	Gathering client/stakeholder needs
    •	Writing functional (what it does) and non-functional (how well it does it) requirements
    •	Possibly writing user stories, use cases, and even formal specifications

⸻

3. Design Techniques

“How do we plan the software structure before building it?”

    •	UML diagrams (like:
    •	Class diagrams
    •	Sequence diagrams
    •	Activity diagrams
    •	Low-level vs high-level design
    •	Common design principles (like SOLID)

⸻

4. Software Testing

“How do we make sure our code actually works — and keeps working?”

    •	Unit testing (testing small parts of code)
    •	Integration testing (testing how parts work together)
    •	System & Acceptance testing (testing overall product)
    •	Writing test plans, test cases, test coverage
    •	Test-Driven Development (TDD)

⸻

5. Teamwork & Project Management

You likely worked on a team project where you had to:
• Use version control (e.g., Git)
• Have standups or sprint planning meetings (Agile-style)
• Write documentation
• Track tasks (e.g., Trello, Jira, GitHub Projects)

⸻

6. Cost & Time Estimation

“How long will this project take? How much will it cost?”

    •	You may have touched on:
    •	Function Point Analysis
    •	COCOMO model (Constructive Cost Model)

Effort = a \* (KLOC)^b

⸻

7. Software Quality Assurance (SQA)

“How do we guarantee quality?”

    •	Writing quality standards
    •	Code reviews
    •	Defect tracking
    •	Continuous Integration/Continuous Delivery (CI/CD)

⸻

8. Software Maintenance

“How do we keep the software running long after it’s launched?”

    •	Bug fixing
    •	Adapting to new environments (e.g., OS updates)
    •	Adding new features over time
    •	Dealing with technical debt

⸻
